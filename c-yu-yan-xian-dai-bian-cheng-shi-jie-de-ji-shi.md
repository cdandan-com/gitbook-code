# C语言-现代编程世界的基石

**C语言**作为一种通用编程语言，在计算机科学的发展中占据了重要的地位。自20世纪70年代问世以来，C语言凭借其简洁、高效、灵活等特点，成为系统软件、操作系统、嵌入式系统及应用软件开发的重要工具。本文将带您回顾C语言的发展历程，从其起源到成为现代编程世界的基石。

**一、C语言的起源**

**1. 早期背景：从B语言到C语言的诞生**

C语言的起源可以追溯到20世纪60年代末至70年代初。在这个时期，贝尔实验室的Ken Thompson和Dennis Ritchie开始开发一种新型操作系统，后来被称为Unix。

* **BCPL与B语言**：C语言的最早起源可以追溯到20世纪60年代开发的BCPL（Basic Combined Programming Language）语言，它由Martin Richards设计，用于编写系统软件。Ken Thompson在开发[Unix操作系统](https://so.csdn.net/so/search?q=Unix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\&spm=1001.2101.3001.7020)时，基于BCPL语言设计了一种更简化的语言，称为B语言。
* **C语言的诞生**：B语言虽然简洁，但功能有限。Dennis Ritchie在1972年基于B语言开发出了一种更强大、更灵活的语言，这就是C语言。C语言首次用于重新编写Unix内核，使其可以在不同的硬件平台上移植和运行。

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

C语言之父：丹尼斯·里奇

计算机历史学家Paul E.Ceruzzi说：里奇不被人们之道。他的名字一点都不家喻户晓，但是如果你有一台显微镜，能在电脑里看到他的作品，你会发现处处都是他的作品。

克尼汉也曾如此评价：“牛顿说他是站在巨人的肩膀上，如今，我们都站在里奇的肩膀上。”

#### 01 C语言的辉煌历史

1941年，丹尼斯 · 里奇出生在纽约布朗克斯区，父亲是是贝尔实验室的交换系统工程师。里奇从小成绩优异，大学顺利进入了哈佛，在受父亲的影响下，丹尼斯也走上了科学研究之路。

在哈佛读书期间，一次偶然的机会改变了里奇的一生。里奇参加了哈佛计算机系统相关的讲座，从此他开始对计算机疯狂着迷，不仅专门学了一期课程。

当时的里奇是一个主修物理的学生，因为对计算机处理的理论和实际问题十分着迷，他在毕业论文中大部分和计算机理论有关(递归函数的层次)，这还远远不够，里奇开始花更多的精力在实践上面。

在那个时代，大部分计算机体积十分庞大，占用了整个房间并且还只能进行有限的拨入访问，因此攻克小型台式计算机是当时的工程师们的目标，可是这些计算机没有易于使用的操作系统，于是里奇决定自己做一个。

这一决定立即得到了麻省理工学院Honeywell和General Electric的支持。里奇负责多道处理机BCPL语言和GE650的编译器，它们都是属于GECOS系统的。同时，他还写了ALTRAN语言的代数编译器，那视符号计算机的一种语言和系统。

经过这个项目后，里奇毅然决然的放弃了本专业物理学，并决定将计算机作为他的事业。1967年，他加入了贝尔实验室(Bell Labs)。

在加入贝尔实验室后，里奇开始和实验室的一位名为Ken Thompson(肯·汤普森)的成员合作。这位Ken Thompson也是对Ritchie 职业生涯影响很大的人。

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Thompson和Ritchie

20世纪70年代，汤普森和里奇在研究如何让早期小型机变得越来越受欢迎。他们认为，所需要的是各种计算机之间更简单，更可行的交互。因为老型计算机要求用户使用操作系统来复制，删除，编辑和打印数据文件，将数据从磁盘移动到屏幕到打印机并返回磁盘进行存储。除了少数专家之外，一旦没有了操作系统，任何人都无法访问计算机。

为此，他们花了几个月的时间来提出解决方案，他们完成这个解决方案时已经编写好了影响他们一生的Unix操作系统。

里奇在1999年的一次采访中表示：“我觉得Linux发展的现象令人高兴，虽然工作站和大型计算机厂商也在提供不同种类的BSD系统，但是在Unix的直接派生品中，Linux应该是最健全的了。

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

C++的开发者和设计师比雅尼 · 斯特劳斯普曾说：“假如里奇决定那十年将他的精力花费在稀奇古怪的数学上，那么Unix将胎死腹中。”

事实上，里奇加入贝尔实验室后，发展了C语言和Unix系统，这在电脑工业史上都占据重要的席位。C语言在发展软件和操作系统时是一个非常常用的电脑语言，而现在的编程语言比如C++、C#、Obijective-C、Java和JavaScript拥有极大的影响。

<figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

为了在PDP-11电脑上运行的Unix系统，1972年，美国贝尔实验室的丹尼斯·麦卡利斯泰尔·里奇(Dennis MacAlistair Ritchie)在B语言的基础上的设计了C语言。

C语言最初尝试通过向B语言中增加数据类型的想法来处理那些不同类型的数据。和大多数编程语言一样，在C语言中，每个对象都有一个类型以及一个值;类型决定了可用于值的操作的含义，以及对象占用的存储空间大小。

1973年，肯·汤普逊(Ken Thompson)和里奇合作把Unix的90%以上用C语言改写，即Unix第五版。这是C语言第一次应用在操作系统的核心编写上。随着Unix的日益广泛使用，C语言也迅速得到推广。

Unix最开始是用汇编语言编写的，里奇和汤普森重写了之后于1974年在ACM上发表，正式向外界披露Unix系统。

随着Unix的发展，C语言也得到了不断地完善。C语言是一门面向过程地、抽象化的编程语言，广泛应用于底层开发。C语言能用简易的方式编译、处理低级存储器。如此简单，简洁，几乎每个计算机制造商都转向了它，且效果显著。

为了利于C语言的全面推广，很多专家学者和硬件产商联合组成了C语言标准委员会。于是在1989年，第一个完备的C标准诞生了，简称“C89”，截至目前，最新的C语言标准为2017年发布的“C17”。

尽管C语言已经如日朝天，但里奇的职业生涯并没没有因此而结束，他于1990年成为朗讯科技计算技术研究部门的领导者。在该职位上，他编写了应用程序并管理已发布的操作系统的增长。

1975年，C语言开始移植到其他机器上使用。史蒂芬·强生(Stephen C.Johnson)实现了一套“可移植编译器”，这套编译器修改起来相对容易，并且可以为不同的机器生成代码。从那时起，C语言在大多数计算机上被使用，从最小的微型计算机到CRAY-2超级计算机。C语言很规范，即使没有一份正式的标准，也可以写出C程序，这些程序无需修改就可以运行在任何支持C语言的最小运行时环境的计算机上。

1978年，丹尼斯·里奇和布莱恩·柯林汉(Brian Wilson Kernighan)合作出版了《C程序设计语言》的第一版。书中介绍的C语言标准也被C语言程序员称作“K\&amp;R C”(柯里C)，第二版的书中也包含了一些ANSI C的标准。即使在后来ANSI C标准被提出的许多年后，K\&R C仍然是许多编译器的最低标准要求，许多老旧的编译仍然运行K\&R C的标准。

1978年以后，C语言先后移植到大，中，小和微型计算机上。C语言便很快风靡全球，成为世界上应用最为广泛的程序设计高级语言。

C最初在小型机器上实现，并且继承了一系列小语种编程语言的特点;与功能相比，C的设计者更倾向于简单和优雅。此外，从一开始，C语言就是为系统级编程而设计，程序的运行效率至关重要，因此，C语言与真实机器能力的良好匹配也就不足为奇。例如，C语言为典型硬件所直接支持的对象：字符，整数(也许有多种大小)，以及浮点数(同样可能有多种大小)提供了相应的基本数据类型。

1983年，因为发展了通用操作系统理论并实现了UNIX操作系统，里奇和汤普森二人一起获得了图灵奖。里奇的图灵奖论文题目为《对软件研究的反思》。

<figure><img src=".gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

1989年，C语言被美国国家标准协会(ANSI)标准化，编号为ANSI X3.159-1989。这个版本又称为C89。标准化的一个目的是扩展K\&R C，增加了一些新特性。

1990年，国际标准化组织(ISO)成立 ISO/IEC JTC1/SC22/WG14 工作组，来规定国际标准的C语言，通过对ANSI标准的少量修改，最终制定了 ISO 9899:1990，又称为C90。随后，ANSI亦接受国际标准C，并不再发展新的C标准。

在ANSI的标准确立后，C语言的规范在一段时间内没有大的变动，然而C++在自己的标准化创建过程中继续发展壮大。《标准修正案一》在1994年为C语言创建了一个新标准，但是只修正了一些C89标准中的细节和增加更多更广的国际字符集支持。不过，这个标准引出了1999年ISO 9899:1999的发表。它通常被称为C99。C99被ANSI于2000年3月采用。

1990年，童年，二人因“创造UNIX操作系统和C程序设计语言”而获得了IEEE颁发的IEEE汉明奖，1997年获计算机历史博物馆研究员奖，2005年，美国工业研究院授予里奇 IRI成就奖，以表彰他对计算机科学技术做出的贡献，以及UNIX操作系统对社会的广泛影响。2011年，里奇和汤普森二人共同获得了日本国际奖。

但在2011年10月12日，里奇离开了这个世界，离开了他付出一生的C语言和Unix世界，享年70岁，去往另一个地方开始了他的另一场旅行……

2011年12月8日，ISO正式发布了新的C语言的新标准C11，之前被称为C1X，官方名称为ISO/IEC 9899:2011。新的标准提高了对C++的兼容性，并增加了一些新的特性。这些新特性包括泛型宏、多线程、带边界检查的函数、匿名结构等。

C18(以前称为C17)最新标准的C语言编程，发表在2018年六月代替C11。C18在没有引入新语言功能的情况下解决了C11中的缺陷。

由于C具有语言简洁，紧凑，使用方便灵活。运算符，数据类型丰富;具有结构化的控制语句，语法限制不太严格，程序设计自由度大;C语言允许直接访问物理地址，能进行位操作，能实现汇编语言的大部分功能，可以直接对硬件进行操作;生成目标代码质量高。执行效率高，等特点。所以，尽管C语言发布至今过去很多年，但现在C语言仍然在一些领域流行。

当前，C语言编译器普遍存在于各种不同的操作系统中，例如Microsoft Windows、macOS、Linux、Unix等。C语言的设计影响了众多后来的编程语言，例如C++、Objective-C、Java、C#等。

从计算机发展以来，编程语言也是层出不穷，但是无论多少“新人”翻涌而出，都无法改变C语言在编程界中德高望重的地位。

C语言到底能做了多少事情?大家经常说的Linux操作系统的内核都是C语言写的，对应的很多嵌入式内核驱动也跑不出C语言范畴，包括大家常用的手机，机顶盒，电视机底层硬件驱动基本上都是C语言完成。

可以毫不夸张的说，如果没有C语言，就没有微软的Windows 10 和 Surface Book，也没有安卓智能手机，更没有乔布斯创造的苹果帝国各种产品MAC、iPad。

C语言最牛的地方，几乎现在所有的上层语言的底层语言绝大部分都是C语言大哥做嫁衣给铺垫完成。深刻理解上层语言底层实现，离不开C语言。而且很多大学的计算机专业都会把C语言作为学生入门编程的第一步。因此，很多程序员都把学习C语言当成程序生涯中最基本的事。

#### C语言是怎么来的

C语言是很低级的语言，很多方面都近似于汇编语言，在《Intel 32位汇编语言程序设计》一书中，甚至介绍了手工把简单的C语言翻译成汇编的方法。对于编译器这种系统软件，用C语言来编写是很自然不过的，即使是像Python这样的高级语言依然在底层依赖于C语言(举Python的例子是因为Intel的黑客正在尝试让

Python不需要操作系统就能运行——实际上是免去了BIOS上的一次性C代码)。现在的学生，学过编译原理后，只要有点编程能力的都可以实现一个功能简单的类C语言编译器。

可是问题来了，不知道你有没有想过，大家都用C语言或基于C语言的语言来写编译器，那么世界上第一个C语言编译器又是怎么编写的呢?这不是一个“鸡和蛋”的问题……

上文也有提到第一个C语言编译器的原型完全可能是用B语言或者混合B语言与PDP汇编语言编写的。

早期的C语言编译器采取了一个取巧的办法：先用汇编语言编写一个C语言的一个子集的编译器，再通过这个子集去递推完成完整的C语言编译器。详细的过程如下：

先创造一个只有C语言最基本功能的子集，记作C0语言，C0语言已经足够简单了，可以直接用汇编语言编写出C0的编译器。依靠C0已有的功能，设计比C0复杂，但仍然不完整的C语言的又一个子集C1语言，其中C0属于C1，C1属于C，用C0开发出C1语言的编译器。在C1的基础上设计C语言的又一个子集C2语言，C2语言比C1复杂，但是仍然不是完整的C语言，开发出C2语言的编译器……如此直到CN，CN已经足够强大了，这时候就足够开发出完整的C语言编译器的实现了。至于这里的N是多少，这取决于你的目标语言(这里是C语言)的复杂程度和程序员的编程能力——简单地说，如果到了某个子集阶段，可以很方便地利用现有功能实现C语言时，那么你就找到N了。下面的图说明了这个抽象过程：

<figure><img src="https://pic1.zhimg.com/v2-bf1ad219f1341e32b604896fb9078dec_1440w.jpg" alt="" width="550"><figcaption></figcaption></figure>

那么这种大胆的子集简化的方法，是怎么实现的，又有什么理论依据呢?

先介绍一个概念，“自编译”Self-Compile，也就是对于某些具有明显自举性质的强类型(所谓强类型就是程序中的每个变量必须声明类型后才能使用，比如C语言，相反有些脚本语言则根本没有类型这一说法)编程语言，可以借助它们的一个有限小子集，通过有限次数的递推来实现对它们自身的表述，这样的语言有C、Pascal、Ada等等，至于为什么可以自编译，可以参见清华大学出版社的《编译原理》，书中实现了一个Pascal的子集的编译器。

总之，已经有计算机科学家证明了，C语言理论上是可以通过上面说的CVM的方法实现完整的编译器的，那么实际上是怎样做到简化的呢?

这张图是不是有点熟悉?对了就是在讲虚拟机的时候见到过，不过这里是CVM(C Language Virtual Machine)，每种语言都是在每个虚拟层上可以独立实现编译的，并且除了C语言外，每一层的输出都将作为下一层的输入(最后一层的输出就是应用程序了)，这和滚雪球是一个道理。用手(汇编语言)把一小把雪结合在一起，一点点地滚下去就形成了一个大雪球，这大概就是所谓的0生1，1生C，C生万物吧?
